// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'event_info.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

EventInfo _$EventInfoFromJson(Map<String, dynamic> json) {
  return _EventInfo.fromJson(json);
}

/// @nodoc
mixin _$EventInfo {
  int get idEvent => throw _privateConstructorUsedError;
  String get eventName => throw _privateConstructorUsedError;
  String get eventDate => throw _privateConstructorUsedError;
  String get eventHour => throw _privateConstructorUsedError;
  String get eventLocation => throw _privateConstructorUsedError;
  String get eventDescription => throw _privateConstructorUsedError;
  int? get idGenre => throw _privateConstructorUsedError;
  String? get genreName => throw _privateConstructorUsedError;
  List<dynamic> get eventInvitationId => throw _privateConstructorUsedError;

  /// Serializes this EventInfo to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of EventInfo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $EventInfoCopyWith<EventInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EventInfoCopyWith<$Res> {
  factory $EventInfoCopyWith(EventInfo value, $Res Function(EventInfo) then) =
      _$EventInfoCopyWithImpl<$Res, EventInfo>;
  @useResult
  $Res call(
      {int idEvent,
      String eventName,
      String eventDate,
      String eventHour,
      String eventLocation,
      String eventDescription,
      int? idGenre,
      String? genreName,
      List<dynamic> eventInvitationId});
}

/// @nodoc
class _$EventInfoCopyWithImpl<$Res, $Val extends EventInfo>
    implements $EventInfoCopyWith<$Res> {
  _$EventInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of EventInfo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? idEvent = null,
    Object? eventName = null,
    Object? eventDate = null,
    Object? eventHour = null,
    Object? eventLocation = null,
    Object? eventDescription = null,
    Object? idGenre = freezed,
    Object? genreName = freezed,
    Object? eventInvitationId = null,
  }) {
    return _then(_value.copyWith(
      idEvent: null == idEvent
          ? _value.idEvent
          : idEvent // ignore: cast_nullable_to_non_nullable
              as int,
      eventName: null == eventName
          ? _value.eventName
          : eventName // ignore: cast_nullable_to_non_nullable
              as String,
      eventDate: null == eventDate
          ? _value.eventDate
          : eventDate // ignore: cast_nullable_to_non_nullable
              as String,
      eventHour: null == eventHour
          ? _value.eventHour
          : eventHour // ignore: cast_nullable_to_non_nullable
              as String,
      eventLocation: null == eventLocation
          ? _value.eventLocation
          : eventLocation // ignore: cast_nullable_to_non_nullable
              as String,
      eventDescription: null == eventDescription
          ? _value.eventDescription
          : eventDescription // ignore: cast_nullable_to_non_nullable
              as String,
      idGenre: freezed == idGenre
          ? _value.idGenre
          : idGenre // ignore: cast_nullable_to_non_nullable
              as int?,
      genreName: freezed == genreName
          ? _value.genreName
          : genreName // ignore: cast_nullable_to_non_nullable
              as String?,
      eventInvitationId: null == eventInvitationId
          ? _value.eventInvitationId
          : eventInvitationId // ignore: cast_nullable_to_non_nullable
              as List<dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EventInfoImplCopyWith<$Res>
    implements $EventInfoCopyWith<$Res> {
  factory _$$EventInfoImplCopyWith(
          _$EventInfoImpl value, $Res Function(_$EventInfoImpl) then) =
      __$$EventInfoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int idEvent,
      String eventName,
      String eventDate,
      String eventHour,
      String eventLocation,
      String eventDescription,
      int? idGenre,
      String? genreName,
      List<dynamic> eventInvitationId});
}

/// @nodoc
class __$$EventInfoImplCopyWithImpl<$Res>
    extends _$EventInfoCopyWithImpl<$Res, _$EventInfoImpl>
    implements _$$EventInfoImplCopyWith<$Res> {
  __$$EventInfoImplCopyWithImpl(
      _$EventInfoImpl _value, $Res Function(_$EventInfoImpl) _then)
      : super(_value, _then);

  /// Create a copy of EventInfo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? idEvent = null,
    Object? eventName = null,
    Object? eventDate = null,
    Object? eventHour = null,
    Object? eventLocation = null,
    Object? eventDescription = null,
    Object? idGenre = freezed,
    Object? genreName = freezed,
    Object? eventInvitationId = null,
  }) {
    return _then(_$EventInfoImpl(
      idEvent: null == idEvent
          ? _value.idEvent
          : idEvent // ignore: cast_nullable_to_non_nullable
              as int,
      eventName: null == eventName
          ? _value.eventName
          : eventName // ignore: cast_nullable_to_non_nullable
              as String,
      eventDate: null == eventDate
          ? _value.eventDate
          : eventDate // ignore: cast_nullable_to_non_nullable
              as String,
      eventHour: null == eventHour
          ? _value.eventHour
          : eventHour // ignore: cast_nullable_to_non_nullable
              as String,
      eventLocation: null == eventLocation
          ? _value.eventLocation
          : eventLocation // ignore: cast_nullable_to_non_nullable
              as String,
      eventDescription: null == eventDescription
          ? _value.eventDescription
          : eventDescription // ignore: cast_nullable_to_non_nullable
              as String,
      idGenre: freezed == idGenre
          ? _value.idGenre
          : idGenre // ignore: cast_nullable_to_non_nullable
              as int?,
      genreName: freezed == genreName
          ? _value.genreName
          : genreName // ignore: cast_nullable_to_non_nullable
              as String?,
      eventInvitationId: null == eventInvitationId
          ? _value._eventInvitationId
          : eventInvitationId // ignore: cast_nullable_to_non_nullable
              as List<dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EventInfoImpl implements _EventInfo {
  const _$EventInfoImpl(
      {required this.idEvent,
      required this.eventName,
      required this.eventDate,
      required this.eventHour,
      required this.eventLocation,
      required this.eventDescription,
      required this.idGenre,
      required this.genreName,
      required final List<dynamic> eventInvitationId})
      : _eventInvitationId = eventInvitationId;

  factory _$EventInfoImpl.fromJson(Map<String, dynamic> json) =>
      _$$EventInfoImplFromJson(json);

  @override
  final int idEvent;
  @override
  final String eventName;
  @override
  final String eventDate;
  @override
  final String eventHour;
  @override
  final String eventLocation;
  @override
  final String eventDescription;
  @override
  final int? idGenre;
  @override
  final String? genreName;
  final List<dynamic> _eventInvitationId;
  @override
  List<dynamic> get eventInvitationId {
    if (_eventInvitationId is EqualUnmodifiableListView)
      return _eventInvitationId;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_eventInvitationId);
  }

  @override
  String toString() {
    return 'EventInfo(idEvent: $idEvent, eventName: $eventName, eventDate: $eventDate, eventHour: $eventHour, eventLocation: $eventLocation, eventDescription: $eventDescription, idGenre: $idGenre, genreName: $genreName, eventInvitationId: $eventInvitationId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EventInfoImpl &&
            (identical(other.idEvent, idEvent) || other.idEvent == idEvent) &&
            (identical(other.eventName, eventName) ||
                other.eventName == eventName) &&
            (identical(other.eventDate, eventDate) ||
                other.eventDate == eventDate) &&
            (identical(other.eventHour, eventHour) ||
                other.eventHour == eventHour) &&
            (identical(other.eventLocation, eventLocation) ||
                other.eventLocation == eventLocation) &&
            (identical(other.eventDescription, eventDescription) ||
                other.eventDescription == eventDescription) &&
            (identical(other.idGenre, idGenre) || other.idGenre == idGenre) &&
            (identical(other.genreName, genreName) ||
                other.genreName == genreName) &&
            const DeepCollectionEquality()
                .equals(other._eventInvitationId, _eventInvitationId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      idEvent,
      eventName,
      eventDate,
      eventHour,
      eventLocation,
      eventDescription,
      idGenre,
      genreName,
      const DeepCollectionEquality().hash(_eventInvitationId));

  /// Create a copy of EventInfo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EventInfoImplCopyWith<_$EventInfoImpl> get copyWith =>
      __$$EventInfoImplCopyWithImpl<_$EventInfoImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EventInfoImplToJson(
      this,
    );
  }
}

abstract class _EventInfo implements EventInfo {
  const factory _EventInfo(
      {required final int idEvent,
      required final String eventName,
      required final String eventDate,
      required final String eventHour,
      required final String eventLocation,
      required final String eventDescription,
      required final int? idGenre,
      required final String? genreName,
      required final List<dynamic> eventInvitationId}) = _$EventInfoImpl;

  factory _EventInfo.fromJson(Map<String, dynamic> json) =
      _$EventInfoImpl.fromJson;

  @override
  int get idEvent;
  @override
  String get eventName;
  @override
  String get eventDate;
  @override
  String get eventHour;
  @override
  String get eventLocation;
  @override
  String get eventDescription;
  @override
  int? get idGenre;
  @override
  String? get genreName;
  @override
  List<dynamic> get eventInvitationId;

  /// Create a copy of EventInfo
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EventInfoImplCopyWith<_$EventInfoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
